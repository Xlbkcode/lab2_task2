**Документація**

до проекту:

**“ТЕЛЕГРАМ БОТ ДЛЯ КЕРУВАННЯ ВІДДАЛЕНИМ ПК”**

на тему:

**“ВИКОНАВЧИЙ БЛОК КОДУ МОНІТОРИНГУ З 4-Х ОКРЕМИХ, АСИНХРОННИХ ФУНКЦІЙ”**

**Автор: Вошкулат Ярослав**

**МКІ-41**

**2025**

Розглянемо більш детально функції створені під час розробки проєкту. Почнемо з моніторингу системи функціонал якої реалізовано в файлі handler.py. Виконавчий блок коду складається з 4-х окремих, асинхронних функцій, що взаємодіють між один одним.

 Спрощений принцип взаємодії показано на діаг. 1.

Оглянемо кожну з них окремо. Почнемо з простого, функції “start_monitoring”. Її основна роль збирання необхідної інформації для запуску процесу моніторингу


```
async def start_monitoring(callback: types.CallbackQuery):
	chat_id = callback.message.chat.id
	if chat_id in monitoring_tasks:
    	await bot.send_message(callback.from_user.id, "Моніторинг вже працює.")
	else:
    	task = asyncio.create_task(send_system_usage(callback))
    	monitoring_tasks[chat_id] = task
```


Конструкція if else в цій функції використовується для визначення виконується в даний момент часу процес моніторингу чи ні. Якщо chat.id вже записаний в список monitoring_task, тоді бот надішле повідомлення “Моніторинг вже працює”, це треба для того щоб уникнути дублювання та зайвого навантаження. 

Якщо, після перевірки бот не знайде відповідного chat.id, тоді створить асинхронну задачу(send_system_usage) та додасть chat.id у список monitoring_tasks.

Функція “stop_monitoring” виконує схожу задачу, але робить це навпаки. Вона отримує callback.message.chat.id у змінну chat_id. Використовуючи конструкцію if else, порівнює чи знаходиться chat.id у списку, якщо так то видаляє його тим самим зупиняючи процес моніторингу, а якщо ні то надсилає повідомлення, що активного процесу моніторингу не знайдено.


```
async def stop_monitoring(callback: types.CallbackQuery):
	chat_id = callback.message.chat.id
	task = monitoring_tasks.pop(chat_id, None)
	if task:
    	task.cancel()
    	await bot.send_message(callback.from_user.id, "Моніторинг системи зупинено.")
	else:
    	await bot.send_message(callback.from_user.id, "Активного процесу моніторингу не знайдено.")
```


Функція get_system_usage є асинхронною і збирає статистику використання системних віддаленої системи ресурсів. Спочатку вона визначає відсоток використання процесора, викликаючи метод psutil.cpu_percent з інтервалом у 1 секунду. Далі отримує інформацію про використання оперативної пам'яті через psutil.virtual_memory і зберігає відсоток використання пам'яті в змінну. 

Для збору статистики мережевого вводу/виводу функція використовує psutil.net_io_counters, отримуючи початкові значення байтів, які були відправлені та отримані. Після цього функція робить паузу на 1 секунду, щоб зібрати дані про мережевий трафік за цей проміжок часу, і знову викликає psutil.net_io_counters для отримання нових значень. 

Для розрахунку швидкості передачі і прийому даних у МБ/с, функція обчислює різницю між новими і початковими значеннями байтів, ділячи на 1024 * 1024 і враховуючи час у секундах. 

Після обчислень функція повертає форматований рядок, який містить відсоток використання процесора, відсоток зайнятої оперативної пам'яті, швидкість передачі даних у МБ/с і швидкість прийому даних у МБ/с


```
async def get_system_usage():
	cpu_usage = psutil.cpu_percent(interval=1)
	memory_info = psutil.virtual_memory()
	memory_usage = memory_info.percent
	# Збір статистик
	net_io_1 = psutil.net_io_counters()
	await asyncio.sleep(1)
	net_io_2 = psutil.net_io_counters()

	# Розрахунок швидкості в MB/s
	bytes_sent_per_sec = (net_io_2.bytes_sent - net_io_1.bytes_sent) / (1024 * 1024)
	bytes_recv_per_sec = (net_io_2.bytes_recv - net_io_1.bytes_recv) / (1024 * 1024)

	return (f"Відсоток використання ЦП: {cpu_usage}%\n"
        	f"Відсоток зайнятої ОЗП: {memory_usage}%\n"
        	f"Швидкість передачі даних: {bytes_sent_per_sec:.2f} MB/s\n"
        	f"Швидкість прийому даних: {bytes_recv_per_sec:.2f} MB/s")
```


Наступною і останньою функцією в блоці моніторингу йде, “send_system_usage”. Роблячи висновок з назви, вона відповідає за надсилання зібраних даних користувачу. 

Функція “send_system_usage” є асинхронною і приймає об'єкт callback типу types.CallbackQuery. Спочатку вона відправляє повідомлення в чат, використовуючи метод bot.send_message, з текстом "Початок моніторингу системи...". Ідентифікатор чату витягується з повідомлення в callback і зберігається в змінній chat_id. Функція входить в нескінченний цикл, у якому через кожні 5 секунд викликається асинхронна функція “get_system_usage” для отримання інформації про використання системи. Після цього функція намагається оновити повідомлення в чаті з новою інформацією про використання системи, використовуючи при цьому метод bot.edit_message_text. Якщо виникає виключення, воно фіксується та виводиться в командний рядок з текстом "Помилка: (опис помилки)". Функція також виконує перевірку, чи знаходиться chat_id у списку “monitoring_tasks”. Якщо chat_id не знайдено, цикл завершується, і функція припиняє своє виконання, таким чином реалізована зупинка процесу моніторингу.

  <tr>
   <td>

```
async def send_system_usage(callback: types.CallbackQuery):
	msg = await bot.send_message(callback.from_user.id, "Початок моніторингу системи...")
	chat_id = callback.message.chat.id

	while True:
    	usage_info = await get_system_usage()
    	try:
        	await bot.edit_message_text(usage_info, chat_id=msg.chat.id, message_id=msg.message_id)
    	except Exception as e:
        	print(f"Помилка: {e}")

    	await asyncio.sleep(5)

    	if chat_id not in monitoring_tasks:
        	break
```


   </td>
  </tr>
